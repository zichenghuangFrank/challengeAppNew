{
  "_args": [
    [
      {
        "raw": "minipass-flush@^1.0.5",
        "scope": null,
        "escapedName": "minipass-flush",
        "name": "minipass-flush",
        "rawSpec": "^1.0.5",
        "spec": ">=1.0.5 <2.0.0",
        "type": "range"
      },
      "C:\\Users\\ziche\\Desktop\\challenge\\node_modules\\@vue\\cli-service\\node_modules\\cacache"
    ]
  ],
  "_from": "minipass-flush@^1.0.5",
  "_hasShrinkwrap": false,
  "_id": "minipass-flush@1.0.5",
  "_location": "/minipass-flush",
  "_nodeVersion": "12.8.1",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/minipass-flush_1.0.5_1569876888688_0.9645134726115252"
  },
  "_npmUser": {
    "name": "isaacs",
    "email": "i@izs.me"
  },
  "_npmVersion": "6.12.0-next.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "minipass-flush@^1.0.5",
    "scope": null,
    "escapedName": "minipass-flush",
    "name": "minipass-flush",
    "rawSpec": "^1.0.5",
    "spec": ">=1.0.5 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/@vue/cli-service/cacache"
  ],
  "_resolved": "https://registry.npmjs.org/minipass-flush/-/minipass-flush-1.0.5.tgz",
  "_shasum": "82e7135d7e89a50ffe64610a787953c4c4cbb373",
  "_shrinkwrap": null,
  "_spec": "minipass-flush@^1.0.5",
  "_where": "C:\\Users\\ziche\\Desktop\\challenge\\node_modules\\@vue\\cli-service\\node_modules\\cacache",
  "author": {
    "name": "Isaac Z. Schlueter",
    "email": "i@izs.me",
    "url": "https://izs.me"
  },
  "bugs": {
    "url": "https://github.com/isaacs/minipass-flush/issues"
  },
  "dependencies": {
    "minipass": "^3.0.0"
  },
  "description": "A Minipass stream that calls a flush function before emitting 'end'",
  "devDependencies": {
    "tap": "^14.6.9"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-JmQSYYpPUqX5Jyn1mXaRwOda1uQ8HP5KAT/oDSLCzt1BYRhQU0/hDtsB1ufZfEEzMZ9aAVmsBw8+FWsIXlClWw==",
    "shasum": "82e7135d7e89a50ffe64610a787953c4c4cbb373",
    "tarball": "https://registry.npmjs.org/minipass-flush/-/minipass-flush-1.0.5.tgz",
    "fileCount": 4,
    "unpackedSize": 3771,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdkmuZCRA9TVsSAnZWagAAbU0QAJZOgfwMjGwsBXsEKbe4\nkLt82NEj2aO+Hx9DqkBbt0XWoOypu9zNzY5kknQQBGSY+qT2yL0IkisbvC/c\nJkVbRj/rULVUMiYh0fzFzn2dRm7tCsDrI+KMeeGPt5jfs38ZAAnbQEMdwabI\nttqjCC5aSPBu4KZvXuadHGWtccwzkbE8ZoEr5BFFoUSR7ovVpeNkfj3mRXDh\nR0Iv/1YUqkxX3h9QMeDgFMwZTMEbxnd9noR6n71XeIv4FsIzMNf0TSNeC2Q1\nuNWYTaOTzDMCLEUHUIu6ba0tfmi9ZIqTxzJXozGX9YJ76+NoptytoK48v7Lo\nMEwfnuF/TtAAe6WGfcqHOZc0+rF1KnAJPXc05kscsLj4kh199sCDtrFmkKlT\n/I+lBtV5raSGdKVAjNC4ONnNETRij42HDVfvpuGIPUrSvXRLkrcxcjhEI8r6\nb8w8j8GodE7gAoHzUxdbcwARpPcszCOLF1Ttv5jWPSKR+pBzs/qnSDCdBcbu\nPgG5Cypac6wLcmdbpHigsvTN3rX8YHFyqf3ROypeLvxB01oTLWPPcSOf3zj3\nW+kqJ1SeiGVcp7suEbqGO5FxoBQkGm98YPXvk4uDjxQygd8iP6gG3FAR0jYu\n6i5u1TlpeNA1B3ZraveU4Uu/vpP2AL96F+ehDHQgDK4S990to6utl6Dk85HZ\nIud+\r\n=EXN3\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "engines": {
    "node": ">= 8"
  },
  "files": [
    "index.js"
  ],
  "gitHead": "9625266c18ca9d14bb13f85dfcdf8cb67763b14e",
  "homepage": "https://github.com/isaacs/minipass-flush#readme",
  "keywords": [
    "minipass",
    "flush",
    "stream"
  ],
  "license": "ISC",
  "main": "index.js",
  "maintainers": [
    {
      "name": "isaacs",
      "email": "i@izs.me"
    }
  ],
  "name": "minipass-flush",
  "optionalDependencies": {},
  "readme": "# minipass-flush\n\nA Minipass stream that calls a flush function before emitting 'end'\n\n## USAGE\n\n```js\nconst Flush = require('minipass-flush')\ncons f = new Flush({\n  flush (cb) {\n    // call the cb when done, or return a promise\n    // the 'end' event will wait for it, along with\n    // close, finish, and prefinish.\n    // call the cb with an error, or return a rejecting\n    // promise to emit 'error' instead of doing the 'end'\n    return rerouteAllEncryptions().then(() => clearAllChannels())\n  },\n  // all other minipass options accepted as well\n})\n\nsomeDataSource.pipe(f).on('end', () => {\n  // proper flushing has been accomplished\n})\n\n// Or as a subclass implementing a 'flush' method:\nclass MyFlush extends Flush {\n  flush (cb) {\n    // old fashioned callback style!\n    rerouteAllEncryptions(er => {\n      if (er)\n        return cb(er)\n      clearAllChannels(er => {\n        if (er)\n          cb(er)\n        cb()\n      })\n    })\n  }\n}\n```\n\nThat's about it.\n\nIf your `flush` method doesn't have to do anything asynchronous, then it's\nbetter to call the callback right away in this tick, rather than returning\n`Promise.resolve()`, so that the `end` event can happen as soon as\npossible.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/isaacs/minipass-flush.git"
  },
  "scripts": {
    "postpublish": "git push origin --follow-tags",
    "postversion": "npm publish",
    "preversion": "npm test",
    "snap": "tap",
    "test": "tap"
  },
  "tap": {
    "check-coverage": true
  },
  "version": "1.0.5"
}
